import * as tslib_1 from "tslib";
import { createScalarNode, SimpleType, TypeFlags, typeCheckSuccess, typeCheckFailure } from "../../internal";
/**
 * `types.custom` - Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.
 *
 * The signature of the options is:
 * ```ts
 * export interface CustomTypeOptions<S, T> {
 *     // Friendly name
 *     name: string
 *     // given a serialized value, how to turn it into the target type
 *     fromSnapshot(snapshot: S): T
 *     // return the serialization of the current value
 *     toSnapshot(value: T): S
 *     // if true, this is a converted value, if false, it's a snapshot
 *     isTargetType(value: T | S): value is T
 *     // a non empty string is assumed to be a validation error
 *     getValidationMessage?(snapshot: S): string
 * }
 * ```
 *
 * Example:
 * ```ts
 * const DecimalPrimitive = types.custom<string, Decimal>({
 *     name: "Decimal",
 *     fromSnapshot(value: string) {
 *         return new Decimal(value)
 *     },
 *     toSnapshot(value: Decimal) {
 *         return value.toString()
 *     },
 *     isTargetType(value: string | Decimal): boolean {
 *         return value instanceof Decimal
 *     },
 *     getValidationMessage(value: string): string {
 *         if (/^-?\d+\.\d+$/.test(value)) return "" // OK
 *         return `'${value}' doesn't look like a valid decimal number`
 *     }
 * })
 *
 * const Wallet = types.model({
 *     balance: DecimalPrimitive
 * })
 * ```
 *
 * @param options
 * @returns
 */
export function custom(options) {
    return new CustomType(options);
}
/**
 * @internal
 * @hidden
 */
var CustomType = /** @class */ (function (_super) {
    tslib_1.__extends(CustomType, _super);
    function CustomType(options) {
        var _this = _super.call(this, options.name) || this;
        _this.options = options;
        _this.flags = TypeFlags.Custom;
        return _this;
    }
    CustomType.prototype.describe = function () {
        return this.name;
    };
    CustomType.prototype.isValidSnapshot = function (value, context) {
        if (this.options.isTargetType(value))
            return typeCheckSuccess();
        var typeError = this.options.getValidationMessage(value);
        if (typeError) {
            return typeCheckFailure(context, value, "Invalid value for type '" + this.name + "': " + typeError);
        }
        return typeCheckSuccess();
    };
    CustomType.prototype.getSnapshot = function (node) {
        return this.options.toSnapshot(node.storedValue);
    };
    CustomType.prototype.instantiate = function (parent, subpath, environment, initialValue) {
        var valueToStore = this.options.isTargetType(initialValue)
            ? initialValue
            : this.options.fromSnapshot(initialValue);
        return createScalarNode(this, parent, subpath, environment, valueToStore);
    };
    CustomType.prototype.reconcile = function (current, value) {
        var isSnapshot = !this.options.isTargetType(value);
        // in theory customs use scalar nodes which cannot be detached, but still...
        if (!current.isDetaching) {
            var unchanged = current.type === this &&
                (isSnapshot ? value === current.snapshot : value === current.storedValue);
            if (unchanged)
                return current;
        }
        var valueToStore = isSnapshot ? this.options.fromSnapshot(value) : value;
        var newNode = this.instantiate(current.parent, current.subpath, current.environment, valueToStore);
        current.die(); // noop if detaching
        return newNode;
    };
    return CustomType;
}(SimpleType));
export { CustomType };
//# sourceMappingURL=custom.js.map