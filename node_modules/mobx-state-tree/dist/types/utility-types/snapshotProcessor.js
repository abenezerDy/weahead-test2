import * as tslib_1 from "tslib";
import { BaseType, isType, isStateTreeNode, TypeFlags } from "../../internal";
var SnapshotProcessor = /** @class */ (function (_super) {
    tslib_1.__extends(SnapshotProcessor, _super);
    function SnapshotProcessor(_subtype, _processors, name) {
        var _this = _super.call(this, name || _subtype.name) || this;
        _this._subtype = _subtype;
        _this._processors = _processors;
        return _this;
    }
    Object.defineProperty(SnapshotProcessor.prototype, "flags", {
        get: function () {
            return this._subtype.flags | TypeFlags.SnapshotProcessor;
        },
        enumerable: true,
        configurable: true
    });
    SnapshotProcessor.prototype.describe = function () {
        return "snapshotProcessor(" + this._subtype.describe() + ")";
    };
    SnapshotProcessor.prototype.preProcessSnapshot = function (sn) {
        if (this._processors.preProcessor) {
            return this._processors.preProcessor.call(null, sn);
        }
        return sn;
    };
    SnapshotProcessor.prototype.postProcessSnapshot = function (sn) {
        if (this._processors.postProcessor) {
            return this._processors.postProcessor.call(null, sn);
        }
        return sn;
    };
    SnapshotProcessor.prototype._fixNode = function (node) {
        var _this = this;
        // the node has to use these methods rather than the original type ones
        proxyNodeTypeMethods(node.type, this, "isAssignableFrom", "create");
        var oldGetSnapshot = node.getSnapshot;
        node.getSnapshot = function () {
            return _this.postProcessSnapshot(oldGetSnapshot.call(node));
        };
    };
    SnapshotProcessor.prototype.instantiate = function (parent, subpath, environment, initialValue) {
        var processedInitialValue = isStateTreeNode(initialValue)
            ? initialValue
            : this.preProcessSnapshot(initialValue);
        var node = this._subtype.instantiate(parent, subpath, environment, processedInitialValue);
        this._fixNode(node);
        return node;
    };
    SnapshotProcessor.prototype.reconcile = function (current, newValue) {
        var node = this._subtype.reconcile(current, isStateTreeNode(newValue) ? newValue : this.preProcessSnapshot(newValue));
        if (node !== current) {
            this._fixNode(node);
        }
        return node;
    };
    SnapshotProcessor.prototype.getSnapshot = function (node, applyPostProcess) {
        if (applyPostProcess === void 0) { applyPostProcess = true; }
        var sn = this._subtype.getSnapshot(node);
        return applyPostProcess ? this.postProcessSnapshot(sn) : sn;
    };
    SnapshotProcessor.prototype.isValidSnapshot = function (value, context) {
        var processedSn = this.preProcessSnapshot(value);
        return this._subtype.validate(processedSn, context);
    };
    SnapshotProcessor.prototype.getSubTypes = function () {
        return this._subtype;
    };
    return SnapshotProcessor;
}(BaseType));
function proxyNodeTypeMethods(nodeType, snapshotProcessorType) {
    var methods = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        methods[_i - 2] = arguments[_i];
    }
    for (var _a = 0, methods_1 = methods; _a < methods_1.length; _a++) {
        var method = methods_1[_a];
        nodeType[method] = snapshotProcessorType[method].bind(snapshotProcessorType);
    }
}
/**
 * `types.snapshotProcessor` - Runs a pre/post snapshot processor before/after serializing a given type.
 *
 * Example:
 * ```ts
 * const Todo1 = types.model({ text: types.string })
 * // in the backend the text type must be null when empty
 * interface BackendTodo {
 *     text: string | null
 * }
 * const Todo2 = types.snapshotProcessor(Todo1, {
 *     // from snapshot to instance
 *     preProcessor(sn: BackendTodo) {
 *         return {
 *             text: sn.text || "";
 *         }
 *     },
 *     // from instance to snapshot
 *     postProcessor(sn): BackendTodo {
 *         return {
 *             text: !sn.text ? null : sn.text
 *         }
 *     }
 * })
 * ```
 *
 * @param type Type to run the processors over.
 * @param processors Processors to run.
 * @param name Type name, or undefined to inherit the inner type one.
 * @returns
 */
export function snapshotProcessor(type, processors, name) {
    if (process.env.NODE_ENV !== "production") {
        if (!isType(type))
            throw fail("expected a mobx-state-tree type as first argument, got " + type + " instead");
        if (processors.postProcessor && typeof processors.postProcessor !== "function") {
            throw fail("postSnapshotProcessor must be a function");
        }
        if (processors.preProcessor && typeof processors.preProcessor !== "function") {
            throw fail("preSnapshotProcessor must be a function");
        }
    }
    return new SnapshotProcessor(type, processors, name);
}
//# sourceMappingURL=snapshotProcessor.js.map