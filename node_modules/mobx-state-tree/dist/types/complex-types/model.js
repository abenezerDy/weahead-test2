import * as tslib_1 from "tslib";
import { _getAdministration, _interceptReads, action, computed, intercept, getAtom, isComputedProp, observable, observe, set } from "mobx";
import { addHiddenFinalProp, addHiddenWritableProp, ArrayType, ComplexType, createActionInvoker, createObjectNode, EMPTY_ARRAY, EMPTY_OBJECT, escapeJsonPath, fail, flattenTypeErrors, freeze, getContextForPath, getPrimitiveFactoryFromValue, getStateTreeNode, isPlainObject, isPrimitive, isStateTreeNode, isType, mobxShallow, optional, MapType, typecheckInternal, typeCheckFailure, TypeFlags, Hook } from "../../internal";
var PRE_PROCESS_SNAPSHOT = "preProcessSnapshot";
var POST_PROCESS_SNAPSHOT = "postProcessSnapshot";
function objectTypeToString() {
    return getStateTreeNode(this).toString();
}
var defaultObjectOptions = {
    name: "AnonymousModel",
    properties: {},
    initializers: EMPTY_ARRAY
};
function toPropertiesObject(declaredProps) {
    // loop through properties and ensures that all items are types
    return Object.keys(declaredProps).reduce(function (props, key) {
        var _a, _b, _c;
        // warn if user intended a HOOK
        if (key in Hook)
            throw fail("Hook '" + key + "' was defined as property. Hooks should be defined as part of the actions");
        // the user intended to use a view
        var descriptor = Object.getOwnPropertyDescriptor(props, key);
        if ("get" in descriptor) {
            throw fail("Getters are not supported as properties. Please use views instead");
        }
        // undefined and null are not valid
        var value = descriptor.value;
        if (value === null || value === undefined) {
            throw fail("The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?");
            // its a primitive, convert to its type
        }
        else if (isPrimitive(value)) {
            return Object.assign({}, props, (_a = {},
                _a[key] = optional(getPrimitiveFactoryFromValue(value), value),
                _a));
            // map defaults to empty object automatically for models
        }
        else if (value instanceof MapType) {
            return Object.assign({}, props, (_b = {},
                _b[key] = optional(value, {}),
                _b));
        }
        else if (value instanceof ArrayType) {
            return Object.assign({}, props, (_c = {}, _c[key] = optional(value, []), _c));
            // its already a type
        }
        else if (isType(value)) {
            return props;
            // its a function, maybe the user wanted a view?
        }
        else if (process.env.NODE_ENV !== "production" && typeof value === "function") {
            throw fail("Invalid type definition for property '" + key + "', it looks like you passed a function. Did you forget to invoke it, or did you intend to declare a view / action?");
            // no other complex values
        }
        else if (process.env.NODE_ENV !== "production" && typeof value === "object") {
            throw fail("Invalid type definition for property '" + key + "', it looks like you passed an object. Try passing another model type or a types.frozen.");
            // WTF did you pass in mate?
        }
        else {
            throw fail("Invalid type definition for property '" + key + "', cannot infer a type from a value like '" + value + "' (" + typeof value + ")");
        }
    }, declaredProps);
}
/**
 * @internal
 * @hidden
 */
var ModelType = /** @class */ (function (_super) {
    tslib_1.__extends(ModelType, _super);
    function ModelType(opts) {
        var _this = _super.call(this, opts.name || defaultObjectOptions.name) || this;
        _this.flags = TypeFlags.Object;
        _this.actions = function (fn) {
            var actionInitializer = function (self) {
                _this.instantiateActions(self, fn(self));
                return self;
            };
            return _this.cloneAndEnhance({ initializers: [actionInitializer] });
        };
        _this.named = function (name) {
            return _this.cloneAndEnhance({ name: name });
        };
        _this.props = function (properties) {
            return _this.cloneAndEnhance({ properties: properties });
        };
        _this.volatile = function (fn) {
            var stateInitializer = function (self) {
                _this.instantiateVolatileState(self, fn(self));
                return self;
            };
            return _this.cloneAndEnhance({ initializers: [stateInitializer] });
        };
        _this.extend = function (fn) {
            var initializer = function (self) {
                var _a = fn(self), actions = _a.actions, views = _a.views, state = _a.state, rest = tslib_1.__rest(_a, ["actions", "views", "state"]);
                for (var key in rest)
                    throw fail("The `extend` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '" + key + "'");
                if (state)
                    _this.instantiateVolatileState(self, state);
                if (views)
                    _this.instantiateViews(self, views);
                if (actions)
                    _this.instantiateActions(self, actions);
                return self;
            };
            return _this.cloneAndEnhance({ initializers: [initializer] });
        };
        _this.views = function (fn) {
            var viewInitializer = function (self) {
                _this.instantiateViews(self, fn(self));
                return self;
            };
            return _this.cloneAndEnhance({ initializers: [viewInitializer] });
        };
        _this.preProcessSnapshot = function (preProcessor) {
            var currentPreprocessor = _this.preProcessor;
            if (!currentPreprocessor)
                return _this.cloneAndEnhance({ preProcessor: preProcessor });
            else
                return _this.cloneAndEnhance({
                    preProcessor: function (snapshot) { return currentPreprocessor(preProcessor(snapshot)); }
                });
        };
        _this.postProcessSnapshot = function (postProcessor) {
            var currentPostprocessor = _this.postProcessor;
            if (!currentPostprocessor)
                return _this.cloneAndEnhance({ postProcessor: postProcessor });
            else
                return _this.cloneAndEnhance({
                    postProcessor: function (snapshot) { return postProcessor(currentPostprocessor(snapshot)); }
                });
        };
        var name = opts.name || defaultObjectOptions.name;
        // TODO: this test still needed?
        if (!/^\w[\w\d_]*$/.test(name))
            throw fail("Typename should be a valid identifier: " + name);
        Object.assign(_this, defaultObjectOptions, opts);
        // ensures that any default value gets converted to its related type
        _this.properties = toPropertiesObject(_this.properties);
        freeze(_this.properties); // make sure nobody messes with it
        _this.propertyNames = Object.keys(_this.properties);
        _this.identifierAttribute = _this._getIdentifierAttribute();
        return _this;
    }
    ModelType.prototype._getIdentifierAttribute = function () {
        var identifierAttribute = undefined;
        this.forAllProps(function (propName, propType) {
            if (propType.flags & TypeFlags.Identifier) {
                if (identifierAttribute)
                    throw fail("Cannot define property '" + propName + "' as object identifier, property '" + identifierAttribute + "' is already defined as identifier property");
                identifierAttribute = propName;
            }
        });
        return identifierAttribute;
    };
    ModelType.prototype.cloneAndEnhance = function (opts) {
        return new ModelType({
            name: opts.name || this.name,
            properties: Object.assign({}, this.properties, opts.properties),
            initializers: this.initializers.concat(opts.initializers || []),
            preProcessor: opts.preProcessor || this.preProcessor,
            postProcessor: opts.postProcessor || this.postProcessor
        });
    };
    ModelType.prototype.instantiateActions = function (self, actions) {
        // check if return is correct
        if (!isPlainObject(actions))
            throw fail("actions initializer should return a plain object containing actions");
        // bind actions to the object created
        Object.keys(actions).forEach(function (name) {
            // warn if preprocessor was given
            if (name === PRE_PROCESS_SNAPSHOT)
                throw fail("Cannot define action '" + PRE_PROCESS_SNAPSHOT + "', it should be defined using 'type.preProcessSnapshot(fn)' instead");
            // warn if postprocessor was given
            if (name === POST_PROCESS_SNAPSHOT)
                throw fail("Cannot define action '" + POST_PROCESS_SNAPSHOT + "', it should be defined using 'type.postProcessSnapshot(fn)' instead");
            var action2 = actions[name];
            // apply hook composition
            var baseAction = self[name];
            if (name in Hook && baseAction) {
                var specializedAction_1 = action2;
                action2 = function () {
                    baseAction.apply(null, arguments);
                    specializedAction_1.apply(null, arguments);
                };
            }
            // the goal of this is to make sure actions using "this" can call themselves,
            // while still allowing the middlewares to register them
            var middlewares = action2.$mst_middleware; // make sure middlewares are not lost
            var boundAction = action2.bind(actions);
            boundAction.$mst_middleware = middlewares;
            var actionInvoker = createActionInvoker(self, name, boundAction);
            actions[name] = actionInvoker;
            (process.env.NODE_ENV === "production" ? addHiddenFinalProp : addHiddenWritableProp)(self, name, actionInvoker);
        });
    };
    ModelType.prototype.instantiateVolatileState = function (self, state) {
        // check views return
        if (!isPlainObject(state))
            throw fail("volatile state initializer should return a plain object containing state");
        set(self, state);
    };
    ModelType.prototype.instantiateViews = function (self, views) {
        // check views return
        if (!isPlainObject(views))
            throw fail("views initializer should return a plain object containing views");
        Object.keys(views).forEach(function (key) {
            // is this a computed property?
            var descriptor = Object.getOwnPropertyDescriptor(views, key);
            var value = descriptor.value;
            if ("get" in descriptor) {
                if (isComputedProp(self, key)) {
                    var computedValue = _getAdministration(self, key);
                    // TODO: mobx currently does not allow redefining computes yet, pending #1121
                    // FIXME: this binds to the internals of mobx!
                    computedValue.derivation = descriptor.get;
                    computedValue.scope = self;
                    if (descriptor.set)
                        computedValue.setter = action(computedValue.name + "-setter", descriptor.set);
                }
                else {
                    // use internal api as shortcut
                    ;
                    computed(self, key, descriptor, true);
                }
            }
            else if (typeof value === "function") {
                // this is a view function, merge as is!
                // See #646, allow models to be mocked
                ;
                (process.env.NODE_ENV === "production"
                    ? addHiddenFinalProp
                    : addHiddenWritableProp)(self, key, value);
            }
            else {
                throw fail("A view member should either be a function or getter based property");
            }
        });
    };
    ModelType.prototype.instantiate = function (parent, subpath, environment, initialValue) {
        var value = isStateTreeNode(initialValue)
            ? initialValue
            : this.applySnapshotPreProcessor(initialValue);
        return createObjectNode(this, parent, subpath, environment, value);
        // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class
        // that pre-reserves all these fields for fast object-member lookups
    };
    ModelType.prototype.initializeChildNodes = function (objNode, initialSnapshot) {
        if (initialSnapshot === void 0) { initialSnapshot = {}; }
        var type = objNode.type;
        var result = {};
        type.forAllProps(function (name, childType) {
            result[name] = childType.instantiate(objNode, name, objNode.environment, initialSnapshot[name]);
        });
        return result;
    };
    ModelType.prototype.createNewInstance = function (node, childNodes) {
        return observable.object(childNodes, EMPTY_OBJECT, mobxShallow);
    };
    ModelType.prototype.finalizeNewInstance = function (node, instance) {
        addHiddenFinalProp(instance, "toString", objectTypeToString);
        this.forAllProps(function (name) {
            _interceptReads(instance, name, node.unbox);
        });
        this.initializers.reduce(function (self, fn) { return fn(self); }, instance);
        intercept(instance, this.willChange);
        observe(instance, this.didChange);
    };
    ModelType.prototype.willChange = function (chg) {
        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop
        var change = chg;
        var childNode = getStateTreeNode(change.object);
        childNode.assertWritable({ subpath: change.name });
        var childType = childNode.type.properties[change.name];
        // only properties are typed, state are stored as-is references
        if (childType) {
            typecheckInternal(childType, change.newValue);
            change.newValue = childType.reconcile(childNode.getChildNode(change.name), change.newValue);
        }
        return change;
    };
    ModelType.prototype.didChange = function (chg) {
        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop
        var change = chg;
        var childNode = getStateTreeNode(change.object);
        var childType = childNode.type.properties[change.name];
        if (!childType) {
            // don't emit patches for volatile state
            return;
        }
        var oldChildValue = change.oldValue ? change.oldValue.snapshot : undefined;
        childNode.emitPatch({
            op: "replace",
            path: escapeJsonPath(change.name),
            value: change.newValue.snapshot,
            oldValue: oldChildValue
        }, childNode);
    };
    ModelType.prototype.getChildren = function (node) {
        var _this = this;
        var res = [];
        this.forAllProps(function (name) {
            res.push(_this.getChildNode(node, name));
        });
        return res;
    };
    ModelType.prototype.getChildNode = function (node, key) {
        if (!(key in this.properties))
            throw fail("Not a value property: " + key);
        var childNode = _getAdministration(node.storedValue, key).value; // TODO: blegh!
        if (!childNode)
            throw fail("Node not available for property " + key);
        return childNode;
    };
    ModelType.prototype.getSnapshot = function (node, applyPostProcess) {
        var _this = this;
        if (applyPostProcess === void 0) { applyPostProcess = true; }
        var res = {};
        this.forAllProps(function (name, type) {
            // TODO: FIXME, make sure the observable ref is used!
            ;
            getAtom(node.storedValue, name).reportObserved();
            res[name] = _this.getChildNode(node, name).snapshot;
        });
        if (applyPostProcess) {
            return this.applySnapshotPostProcessor(res);
        }
        return res;
    };
    ModelType.prototype.processInitialSnapshot = function (childNodes) {
        var processed = {};
        Object.keys(childNodes).forEach(function (key) {
            processed[key] = childNodes[key].getSnapshot();
        });
        return this.applySnapshotPostProcessor(processed);
    };
    ModelType.prototype.applyPatchLocally = function (node, subpath, patch) {
        if (!(patch.op === "replace" || patch.op === "add")) {
            throw fail("object does not support operation " + patch.op);
        }
        node.storedValue[subpath] = patch.value;
    };
    ModelType.prototype.applySnapshot = function (node, snapshot) {
        var preProcessedSnapshot = this.applySnapshotPreProcessor(snapshot);
        typecheckInternal(this, preProcessedSnapshot);
        this.forAllProps(function (name) {
            node.storedValue[name] = preProcessedSnapshot[name];
        });
    };
    ModelType.prototype.applySnapshotPreProcessor = function (snapshot) {
        var processor = this.preProcessor;
        return processor ? processor.call(null, snapshot) : snapshot;
    };
    ModelType.prototype.applySnapshotPostProcessor = function (snapshot) {
        var postProcessor = this.postProcessor;
        if (postProcessor)
            return postProcessor.call(null, snapshot);
        return snapshot;
    };
    ModelType.prototype.getChildType = function (propertyName) {
        if (process.env.NODE_ENV !== "production") {
            if (propertyName === undefined || propertyName === null) {
                throw fail("getChildType requires a property name when used over a model type");
            }
        }
        return this.properties[propertyName];
    };
    ModelType.prototype.isValidSnapshot = function (value, context) {
        var _this = this;
        var snapshot = this.applySnapshotPreProcessor(value);
        if (!isPlainObject(snapshot)) {
            return typeCheckFailure(context, snapshot, "Value is not a plain object");
        }
        return flattenTypeErrors(this.propertyNames.map(function (key) {
            return _this.properties[key].validate(snapshot[key], getContextForPath(context, key, _this.properties[key]));
        }));
    };
    ModelType.prototype.forAllProps = function (fn) {
        var _this = this;
        this.propertyNames.forEach(function (key) { return fn(key, _this.properties[key]); });
    };
    ModelType.prototype.describe = function () {
        var _this = this;
        // optimization: cache
        return ("{ " +
            this.propertyNames.map(function (key) { return key + ": " + _this.properties[key].describe(); }).join("; ") +
            " }");
    };
    ModelType.prototype.getDefaultSnapshot = function () {
        return EMPTY_OBJECT;
    };
    ModelType.prototype.removeChild = function (node, subpath) {
        ;
        node.storedValue[subpath] = undefined;
    };
    tslib_1.__decorate([
        action
    ], ModelType.prototype, "applySnapshot", null);
    return ModelType;
}(ComplexType));
export { ModelType };
/**
 * `types.model` - Creates a new model type by providing a name, properties, volatile state and actions.
 *
 * See the [model type](https://github.com/mobxjs/mobx-state-tree#creating-models) description or the [getting started](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started-1) tutorial.
 */
export function model() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var name = typeof args[0] === "string" ? args.shift() : "AnonymousModel";
    var properties = args.shift() || {};
    return new ModelType({ name: name, properties: properties });
}
/**
 * `types.compose` - Composes a new model from one or more existing model types.
 * This method can be invoked in two forms:
 * Given 2 or more model types, the types are composed into a new Type.
 * Given first parameter as a string and 2 or more model types,
 * the types are composed into a new Type with the given name
 */
export function compose() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // TODO: just join the base type names if no name is provided
    var typeName = typeof args[0] === "string" ? args.shift() : "AnonymousModel";
    // check all parameters
    if (process.env.NODE_ENV !== "production") {
        args.forEach(function (type) {
            if (!isModelType(type))
                throw fail("expected a mobx-state-tree model type, got " + type + " instead");
        });
    }
    return args
        .reduce(function (prev, cur) {
        return prev.cloneAndEnhance({
            name: prev.name + "_" + cur.name,
            properties: cur.properties,
            initializers: cur.initializers,
            preProcessor: function (snapshot) {
                return cur.applySnapshotPreProcessor(prev.applySnapshotPreProcessor(snapshot));
            },
            postProcessor: function (snapshot) {
                return cur.applySnapshotPostProcessor(prev.applySnapshotPostProcessor(snapshot));
            }
        });
    })
        .named(typeName);
}
/**
 * Returns if a given value represents a model type.
 *
 * @param type
 * @returns
 */
export function isModelType(type) {
    return isType(type) && (type.flags & TypeFlags.Object) > 0;
}
//# sourceMappingURL=model.js.map