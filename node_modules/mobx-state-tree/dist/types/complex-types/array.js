import * as tslib_1 from "tslib";
import { _getAdministration, action, intercept, observable, observe } from "mobx";
import { ComplexType, convertChildNodesToArray, EMPTY_ARRAY, fail, flattenTypeErrors, getContextForPath, getStateTreeNode, isArray, isNode, isPlainObject, isStateTreeNode, isType, mobxShallow, ObjectNode, typecheckInternal, typeCheckFailure, TypeFlags, normalizeIdentifier, EMPTY_OBJECT, createObjectNode } from "../../internal";
/**
 * @internal
 * @hidden
 */
var ArrayType = /** @class */ (function (_super) {
    tslib_1.__extends(ArrayType, _super);
    function ArrayType(name, _subType) {
        var _this = _super.call(this, name) || this;
        _this._subType = _subType;
        _this.flags = TypeFlags.Array;
        return _this;
    }
    ArrayType.prototype.instantiate = function (parent, subpath, environment, initialValue) {
        return createObjectNode(this, parent, subpath, environment, initialValue);
    };
    ArrayType.prototype.initializeChildNodes = function (objNode, snapshot) {
        if (snapshot === void 0) { snapshot = []; }
        var subType = objNode.type._subType;
        var environment = objNode.environment;
        var result = {};
        snapshot.forEach(function (item, index) {
            var subpath = "" + index;
            result[subpath] = subType.instantiate(objNode, subpath, environment, item);
        });
        return result;
    };
    ArrayType.prototype.createNewInstance = function (node, childNodes) {
        return observable.array(convertChildNodesToArray(childNodes), mobxShallow);
    };
    ArrayType.prototype.finalizeNewInstance = function (node, instance) {
        _getAdministration(instance).dehancer = node.unbox;
        intercept(instance, this.willChange);
        observe(instance, this.didChange);
    };
    ArrayType.prototype.describe = function () {
        return this._subType.describe() + "[]";
    };
    ArrayType.prototype.getChildren = function (node) {
        return node.storedValue.slice();
    };
    ArrayType.prototype.getChildNode = function (node, key) {
        var index = parseInt(key, 10);
        if (index < node.storedValue.length)
            return node.storedValue[index];
        throw fail("Not a child: " + key);
    };
    ArrayType.prototype.willChange = function (change) {
        var node = getStateTreeNode(change.object);
        node.assertWritable({ subpath: String(change.index) });
        var subType = node.type._subType;
        var childNodes = node.getChildren();
        var nodes = null;
        switch (change.type) {
            case "update":
                if (change.newValue === change.object[change.index])
                    return null;
                nodes = reconcileArrayChildren(node, subType, [childNodes[change.index]], [change.newValue], [change.index]);
                if (!nodes) {
                    return null;
                }
                change.newValue = nodes[0];
                break;
            case "splice":
                var index_1 = change.index, removedCount = change.removedCount, added = change.added;
                nodes = reconcileArrayChildren(node, subType, childNodes.slice(index_1, index_1 + removedCount), added, added.map(function (_, i) { return index_1 + i; }));
                if (!nodes) {
                    return null;
                }
                change.added = nodes;
                // update paths of remaining items
                for (var i = index_1 + removedCount; i < childNodes.length; i++) {
                    childNodes[i].setParent(node, "" + (i + added.length - removedCount));
                }
                break;
        }
        return change;
    };
    ArrayType.prototype.getSnapshot = function (node) {
        return node.getChildren().map(function (childNode) { return childNode.snapshot; });
    };
    ArrayType.prototype.processInitialSnapshot = function (childNodes) {
        var processed = [];
        Object.keys(childNodes).forEach(function (key) {
            processed.push(childNodes[key].getSnapshot());
        });
        return processed;
    };
    ArrayType.prototype.didChange = function (change) {
        var node = getStateTreeNode(change.object);
        switch (change.type) {
            case "update":
                return void node.emitPatch({
                    op: "replace",
                    path: "" + change.index,
                    value: change.newValue.snapshot,
                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined
                }, node);
            case "splice":
                for (var i = change.removedCount - 1; i >= 0; i--)
                    node.emitPatch({
                        op: "remove",
                        path: "" + (change.index + i),
                        oldValue: change.removed[i].snapshot
                    }, node);
                for (var i = 0; i < change.addedCount; i++)
                    node.emitPatch({
                        op: "add",
                        path: "" + (change.index + i),
                        value: node.getChildNode("" + (change.index + i)).snapshot,
                        oldValue: undefined
                    }, node);
                return;
        }
    };
    ArrayType.prototype.applyPatchLocally = function (node, subpath, patch) {
        var target = node.storedValue;
        var index = subpath === "-" ? target.length : parseInt(subpath);
        switch (patch.op) {
            case "replace":
                target[index] = patch.value;
                break;
            case "add":
                target.splice(index, 0, patch.value);
                break;
            case "remove":
                target.splice(index, 1);
                break;
        }
    };
    ArrayType.prototype.applySnapshot = function (node, snapshot) {
        typecheckInternal(this, snapshot);
        var target = node.storedValue;
        target.replace(snapshot);
    };
    ArrayType.prototype.getChildType = function () {
        return this._subType;
    };
    ArrayType.prototype.isValidSnapshot = function (value, context) {
        var _this = this;
        if (!isArray(value)) {
            return typeCheckFailure(context, value, "Value is not an array");
        }
        return flattenTypeErrors(value.map(function (item, index) {
            return _this._subType.validate(item, getContextForPath(context, "" + index, _this._subType));
        }));
    };
    ArrayType.prototype.getDefaultSnapshot = function () {
        return EMPTY_ARRAY;
    };
    ArrayType.prototype.removeChild = function (node, subpath) {
        node.storedValue.splice(parseInt(subpath, 10), 1);
    };
    tslib_1.__decorate([
        action
    ], ArrayType.prototype, "applySnapshot", null);
    return ArrayType;
}(ComplexType));
export { ArrayType };
/**
 * `types.array` - Creates an index based collection type who's children are all of a uniform declared type.
 *
 * This type will always produce [observable arrays](https://mobx.js.org/refguide/array.html)
 *
 * Example:
 * ```ts
 * const Todo = types.model({
 *   task: types.string
 * })
 *
 * const TodoStore = types.model({
 *   todos: types.array(Todo)
 * })
 *
 * const s = TodoStore.create({ todos: [] })
 * unprotect(s) // needed to allow modifying outside of an action
 * s.todos.push({ task: "Grab coffee" })
 * console.log(s.todos[0]) // prints: "Grab coffee"
 * ```
 *
 * @param subtype
 * @returns
 */
export function array(subtype) {
    if (process.env.NODE_ENV !== "production") {
        if (!isType(subtype))
            throw fail("expected a mobx-state-tree type as first argument, got " + subtype + " instead");
    }
    return new ArrayType(subtype.name + "[]", subtype);
}
function reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {
    var nothingChanged = true;
    for (var i = 0;; i++) {
        var hasNewNode = i <= newValues.length - 1;
        var oldNode = oldNodes[i];
        var newValue = hasNewNode ? newValues[i] : undefined;
        var newPath = "" + newPaths[i];
        // for some reason, instead of newValue we got a node, fallback to the storedValue
        // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681
        if (isNode(newValue))
            newValue = newValue.storedValue;
        if (!oldNode && !hasNewNode) {
            // both are empty, end
            break;
        }
        else if (!hasNewNode) {
            // new one does not exists, old one dies
            oldNode.die();
            oldNodes.splice(i, 1);
            i--;
            nothingChanged = false;
        }
        else if (!oldNode) {
            // there is no old node, create it
            // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.
            if (isStateTreeNode(newValue) && getStateTreeNode(newValue).parent === parent) {
                // this node is owned by this parent, but not in the reconcilable set, so it must be double
                throw fail("Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '" + parent.path + "/" + newPath + "', but it lives already at '" + getStateTreeNode(newValue).path + "'");
            }
            oldNodes.splice(i, 0, valueAsNode(childType, parent, newPath, newValue));
            nothingChanged = false;
        }
        else if (areSame(oldNode, newValue)) {
            // both are the same, reconcile
            oldNodes[i] = valueAsNode(childType, parent, newPath, newValue, oldNode);
        }
        else {
            // nothing to do, try to reorder
            var oldMatch = undefined;
            // find a possible candidate to reuse
            for (var j = i; j < oldNodes.length; j++) {
                if (areSame(oldNodes[j], newValue)) {
                    oldMatch = oldNodes.splice(j, 1)[0];
                    break;
                }
            }
            oldNodes.splice(i, 0, valueAsNode(childType, parent, newPath, newValue, oldMatch));
            nothingChanged = false;
        }
    }
    return nothingChanged ? null : oldNodes;
}
/**
 * Convert a value to a node at given parent and subpath. Attempts to reuse old node if possible and given.
 */
function valueAsNode(childType, parent, subpath, newValue, oldNode) {
    // ensure the value is valid-ish
    typecheckInternal(childType, newValue);
    // the new value has a MST node
    if (isStateTreeNode(newValue)) {
        var childNode = getStateTreeNode(newValue);
        childNode.assertAlive(EMPTY_OBJECT);
        // the node lives here
        if (childNode.parent !== null && childNode.parent === parent) {
            childNode.setParent(parent, subpath);
            if (oldNode && oldNode !== childNode)
                oldNode.die();
            return childNode;
        }
    }
    // there is old node and new one is a value/snapshot
    if (oldNode) {
        var childNode = childType.reconcile(oldNode, newValue);
        childNode.setParent(parent, subpath);
        if (childNode !== oldNode)
            oldNode.die();
        return childNode;
    }
    // nothing to do, create from scratch
    return childType.instantiate(parent, subpath, parent.environment, newValue);
}
/**
 * Check if a node holds a value.
 */
function areSame(oldNode, newValue) {
    // never consider dead old nodes for reconciliation
    if (!oldNode.isAlive) {
        return false;
    }
    // the new value has the same node
    if (isStateTreeNode(newValue)) {
        var newNode = getStateTreeNode(newValue);
        return newNode.isAlive && newNode === oldNode;
    }
    // the provided value is the snapshot of the old node
    if (oldNode.snapshot === newValue) {
        return true;
    }
    // new value is a snapshot with the correct identifier
    return (oldNode instanceof ObjectNode &&
        oldNode.identifier !== null &&
        oldNode.identifierAttribute &&
        isPlainObject(newValue) &&
        oldNode.identifier === normalizeIdentifier(newValue[oldNode.identifierAttribute]) &&
        oldNode.type.is(newValue));
}
/**
 * Returns if a given value represents an array type.
 *
 * @param type
 * @returns `true` if the type is an array type.
 */
export function isArrayType(type) {
    return isType(type) && (type.flags & TypeFlags.Array) > 0;
}
//# sourceMappingURL=array.js.map