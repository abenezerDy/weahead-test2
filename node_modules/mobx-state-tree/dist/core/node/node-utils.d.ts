/** @hidden */
declare const $stateTreeNodeTypes: unique symbol;
/**
 * Common interface that represents a node instance.
 * @hidden
 */
export interface IStateTreeNode<C = any, S = any> {
    readonly [$stateTreeNodeTypes]?: [C, S] | [any, any];
}
declare type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;
/** @hidden */
export declare type RedefineIStateTreeNode<T, STN extends IAnyStateTreeNode> = T extends IAnyStateTreeNode ? Omit<T, typeof $stateTreeNodeTypes> & STN : T;
/** @hidden */
export declare type ExtractNodeC<T> = T extends IStateTreeNode<infer C, any> ? C : never;
/** @hidden */
export declare type ExtractNodeS<T> = T extends IStateTreeNode<any, infer S> ? S : never;
/**
 * Represents any state tree node instance.
 * @hidden
 */
export interface IAnyStateTreeNode extends IStateTreeNode<any, any> {
}
/**
 * Returns true if the given value is a node in a state tree.
 * More precisely, that is, if the value is an instance of a
 * `types.model`, `types.array` or `types.map`.
 *
 * @param value
 * @returns true if the value is a state tree node.
 */
export declare function isStateTreeNode<C = any, S = any>(value: any): value is IStateTreeNode<C, S>;
export {};
