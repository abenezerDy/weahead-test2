import * as tslib_1 from "tslib";
// noinspection ES6UnusedImports
import { action, computed, reaction, _allowStateChangesInsideComputed } from "mobx";
import { addHiddenFinalProp, convertChildNodesToArray, createActionInvoker, EMPTY_OBJECT, extend, fail, freeze, IdentifierCache, invalidateComputed, NodeLifeCycle, resolveNodeByPathParts, splitJsonPath, splitPatch, toJSON, EventHandlers, Hook, BaseNode, getLivelinessChecking, normalizeIdentifier, getCurrentActionContext, escapeJsonPath, getPath, warnError } from "../../internal";
var nextNodeId = 1;
var snapshotReactionOptions = {
    onError: function (e) {
        throw e;
    }
};
/**
 * @internal
 * @hidden
 */
var ObjectNode = /** @class */ (function (_super) {
    tslib_1.__extends(ObjectNode, _super);
    function ObjectNode(complexType, parent, subpath, environment, initialValue) {
        var _this = _super.call(this, complexType, parent, subpath, environment) || this;
        _this.nodeId = ++nextNodeId;
        _this.isProtectionEnabled = true;
        _this.middlewares = null;
        _this._autoUnbox = true; // unboxing is disabled when reading child nodes
        _this._isRunningAction = false; // only relevant for root
        _this._hasSnapshotReaction = false;
        _this._observableInstanceState = 0 /* UNINITIALIZED */;
        _this._cachedInitialSnapshotCreated = false;
        _this.unbox = _this.unbox.bind(_this);
        _this._initialSnapshot = freeze(initialValue);
        _this.identifierAttribute = complexType.identifierAttribute;
        if (!parent) {
            _this.identifierCache = new IdentifierCache();
        }
        _this._childNodes = complexType.initializeChildNodes(_this, _this._initialSnapshot);
        // identifier can not be changed during lifecycle of a node
        // so we safely can read it from initial snapshot
        _this.identifier = null;
        _this.unnormalizedIdentifier = null;
        if (_this.identifierAttribute && _this._initialSnapshot) {
            var id = _this._initialSnapshot[_this.identifierAttribute];
            if (id === undefined) {
                // try with the actual node if not (for optional identifiers)
                var childNode = _this._childNodes[_this.identifierAttribute];
                if (childNode) {
                    id = childNode.value;
                }
            }
            if (typeof id !== "string" && typeof id !== "number") {
                throw fail("Instance identifier '" + _this.identifierAttribute + "' for type '" + _this.type.name + "' must be a string or a number");
            }
            // normalize internal identifier to string
            _this.identifier = normalizeIdentifier(id);
            _this.unnormalizedIdentifier = id;
        }
        if (!parent) {
            _this.identifierCache.addNodeToCache(_this);
        }
        else {
            parent.root.identifierCache.addNodeToCache(_this);
        }
        return _this;
    }
    ObjectNode.prototype.applyPatches = function (patches) {
        this.createObservableInstanceIfNeeded();
        this._applyPatches(patches);
    };
    ObjectNode.prototype.applySnapshot = function (snapshot) {
        this.createObservableInstanceIfNeeded();
        this._applySnapshot(snapshot);
    };
    ObjectNode.prototype.createObservableInstanceIfNeeded = function () {
        if (this._observableInstanceState !== 0 /* UNINITIALIZED */) {
            return;
        }
        this._observableInstanceState = 1 /* CREATING */;
        // make sure the parent chain is created as well
        // array with parent chain from parent to child
        var parentChain = [];
        var parent = this.parent;
        // for performance reasons we never go back further than the most direct
        // uninitialized parent
        // this is done to avoid traversing the whole tree to the root when using
        // the same reference again
        while (parent &&
            parent._observableInstanceState === 0 /* UNINITIALIZED */) {
            parentChain.unshift(parent);
            parent = parent.parent;
        }
        // initialize the uninitialized parent chain from parent to child
        for (var _i = 0, parentChain_1 = parentChain; _i < parentChain_1.length; _i++) {
            var p = parentChain_1[_i];
            p.createObservableInstanceIfNeeded();
        }
        var type = this.type;
        try {
            this.storedValue = type.createNewInstance(this, this._childNodes, this._initialSnapshot);
            this.preboot();
            this._isRunningAction = true;
            type.finalizeNewInstance(this, this.storedValue);
        }
        catch (e) {
            // short-cut to die the instance, to avoid the snapshot computed starting to throw...
            this.state = NodeLifeCycle.DEAD;
            throw e;
        }
        finally {
            this._isRunningAction = false;
        }
        this._observableInstanceState = 2 /* CREATED */;
        // NOTE: we need to touch snapshot, because non-observable
        // "_observableInstanceState" field was touched
        invalidateComputed(this, "snapshot");
        if (this.isRoot)
            this._addSnapshotReaction();
        this._childNodes = EMPTY_OBJECT;
        this.state = NodeLifeCycle.CREATED;
        this.fireHook(Hook.afterCreate);
        this.finalizeCreation();
    };
    Object.defineProperty(ObjectNode.prototype, "root", {
        get: function () {
            var parent = this.parent;
            return parent ? parent.root : this;
        },
        enumerable: true,
        configurable: true
    });
    ObjectNode.prototype.setParent = function (newParent, subpath) {
        if (subpath === void 0) { subpath = null; }
        if (this.parent === newParent && this.subpath === subpath)
            return;
        if (newParent && process.env.NODE_ENV !== "production") {
            if (this.parent && newParent !== this.parent) {
                throw fail("A node cannot exists twice in the state tree. Failed to add " + this + " to path '" + newParent.path + "/" + subpath + "'.");
            }
            if (!this.parent && newParent.root === this) {
                throw fail("A state tree is not allowed to contain itself. Cannot assign " + this + " to path '" + newParent.path + "/" + subpath + "'");
            }
            if (!this.parent &&
                !!this.root.environment &&
                this.root.environment !== newParent.root.environment) {
                throw fail("A state tree cannot be made part of another state tree as long as their environments are different.");
            }
        }
        if (this.parent && !newParent) {
            this.die();
        }
        else {
            var newPath = subpath === null ? "" : subpath;
            if (newParent && newParent !== this.parent) {
                newParent.root.identifierCache.mergeCache(this);
                this.baseSetParent(newParent, newPath);
                this.fireHook(Hook.afterAttach);
            }
            else if (this.subpath !== newPath) {
                this.baseSetParent(this.parent, newPath);
            }
        }
    };
    ObjectNode.prototype.fireHook = function (name) {
        var _this = this;
        this.fireInternalHook(name);
        var fn = this.storedValue &&
            typeof this.storedValue === "object" &&
            this.storedValue[name];
        if (typeof fn === "function") {
            // we check for it to allow old mobx peer dependencies that don't have the method to work (even when still bugged)
            if (_allowStateChangesInsideComputed) {
                _allowStateChangesInsideComputed(function () {
                    fn.apply(_this.storedValue);
                });
            }
            else {
                fn.apply(this.storedValue);
            }
        }
    };
    Object.defineProperty(ObjectNode.prototype, "snapshot", {
        // advantage of using computed for a snapshot is that nicely respects transactions etc.
        get: function () {
            return freeze(this.getSnapshot());
        },
        enumerable: true,
        configurable: true
    });
    // NOTE: we use this method to get snapshot without creating @computed overhead
    ObjectNode.prototype.getSnapshot = function () {
        if (!this.isAlive)
            return this._snapshotUponDeath;
        return this._observableInstanceState === 2 /* CREATED */
            ? this._getActualSnapshot()
            : this._getCachedInitialSnapshot();
    };
    ObjectNode.prototype._getActualSnapshot = function () {
        return this.type.getSnapshot(this);
    };
    ObjectNode.prototype._getCachedInitialSnapshot = function () {
        if (!this._cachedInitialSnapshotCreated) {
            var type = this.type;
            var childNodes = this._childNodes;
            var snapshot = this._initialSnapshot;
            this._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);
            this._cachedInitialSnapshotCreated = true;
        }
        return this._cachedInitialSnapshot;
    };
    ObjectNode.prototype.isRunningAction = function () {
        if (this._isRunningAction)
            return true;
        if (this.isRoot)
            return false;
        return this.parent.isRunningAction();
    };
    ObjectNode.prototype.assertAlive = function (context) {
        var livelinessChecking = getLivelinessChecking();
        if (!this.isAlive && livelinessChecking !== "ignore") {
            var error = this._getAssertAliveError(context);
            switch (livelinessChecking) {
                case "error":
                    throw fail(error);
                case "warn":
                    warnError(error);
            }
        }
    };
    ObjectNode.prototype._getAssertAliveError = function (context) {
        var escapedPath = this.getEscapedPath(false) || this.pathUponDeath || "";
        var subpath = (context.subpath && escapeJsonPath(context.subpath)) || "";
        var actionContext = context.actionContext || getCurrentActionContext();
        var actionFullPath = "";
        if (actionContext && actionContext.name != null) {
            // try to use the context, and if it not available use the node one
            var actionPath = (actionContext && actionContext.context && getPath(actionContext.context)) ||
                escapedPath;
            actionFullPath = actionPath + "." + actionContext.name + "()";
        }
        return "You are trying to read or write to an object that is no longer part of a state tree. (Object type: '" + this.type.name + "', Path upon death: '" + escapedPath + "', Subpath: '" + subpath + "', Action: '" + actionFullPath + "'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.";
    };
    ObjectNode.prototype.getChildNode = function (subpath) {
        this.assertAlive({
            subpath: subpath
        });
        this._autoUnbox = false;
        try {
            return this._observableInstanceState === 2 /* CREATED */
                ? this.type.getChildNode(this, subpath)
                : this._childNodes[subpath];
        }
        finally {
            this._autoUnbox = true;
        }
    };
    ObjectNode.prototype.getChildren = function () {
        this.assertAlive(EMPTY_OBJECT);
        this._autoUnbox = false;
        try {
            return this._observableInstanceState === 2 /* CREATED */
                ? this.type.getChildren(this)
                : convertChildNodesToArray(this._childNodes);
        }
        finally {
            this._autoUnbox = true;
        }
    };
    ObjectNode.prototype.getChildType = function (propertyName) {
        return this.type.getChildType(propertyName);
    };
    Object.defineProperty(ObjectNode.prototype, "isProtected", {
        get: function () {
            return this.root.isProtectionEnabled;
        },
        enumerable: true,
        configurable: true
    });
    ObjectNode.prototype.assertWritable = function (context) {
        this.assertAlive(context);
        if (!this.isRunningAction() && this.isProtected) {
            throw fail("Cannot modify '" + this + "', the object is protected and can only be modified by using an action.");
        }
    };
    ObjectNode.prototype.removeChild = function (subpath) {
        this.type.removeChild(this, subpath);
    };
    // bound on the constructor
    ObjectNode.prototype.unbox = function (childNode) {
        if (childNode)
            this.assertAlive({
                subpath: childNode.subpath || childNode.subpathUponDeath
            });
        if (childNode && this._autoUnbox)
            return childNode.value;
        return childNode;
    };
    ObjectNode.prototype.toString = function () {
        var identifier = this.identifier ? "(id: " + this.identifier + ")" : "";
        return this.type.name + "@" + (this.path || "<root>") + identifier + (this.isAlive ? "" : "[dead]");
    };
    ObjectNode.prototype.finalizeCreation = function () {
        var _this = this;
        this.baseFinalizeCreation(function () {
            for (var _i = 0, _a = _this.getChildren(); _i < _a.length; _i++) {
                var child = _a[_i];
                child.finalizeCreation();
            }
            _this.fireInternalHook(Hook.afterCreationFinalization);
        });
    };
    ObjectNode.prototype.detach = function () {
        if (!this.isAlive)
            throw fail("Error while detaching, node is not alive.");
        if (this.isRoot)
            return;
        this.fireHook(Hook.beforeDetach);
        this.state = NodeLifeCycle.DETACHING;
        var root = this.root;
        var newEnv = root.environment;
        var newIdCache = root.identifierCache.splitCache(this);
        try {
            this.parent.removeChild(this.subpath);
            this.baseSetParent(null, "");
            this.environment = newEnv;
            this.identifierCache = newIdCache;
        }
        finally {
            this.state = NodeLifeCycle.FINALIZED;
        }
    };
    ObjectNode.prototype.preboot = function () {
        var self = this;
        this._applyPatches = createActionInvoker(this.storedValue, "@APPLY_PATCHES", function (patches) {
            patches.forEach(function (patch) {
                var parts = splitJsonPath(patch.path);
                var node = resolveNodeByPathParts(self, parts.slice(0, -1));
                node.applyPatchLocally(parts[parts.length - 1], patch);
            });
        });
        this._applySnapshot = createActionInvoker(this.storedValue, "@APPLY_SNAPSHOT", function (snapshot) {
            // if the snapshot is the same as the current one, avoid performing a reconcile
            if (snapshot === self.snapshot)
                return;
            // else, apply it by calling the type logic
            return self.type.applySnapshot(self, snapshot);
        });
        addHiddenFinalProp(this.storedValue, "$treenode", this);
        addHiddenFinalProp(this.storedValue, "toJSON", toJSON);
    };
    ObjectNode.prototype.die = function () {
        if (this.state === NodeLifeCycle.DETACHING)
            return;
        if (this._observableInstanceState === 2 /* CREATED */) {
            this.aboutToDie();
            this.finalizeDeath();
        }
        else {
            // get rid of own and child ids at least
            this.unregisterIdentifiers();
        }
    };
    ObjectNode.prototype.aboutToDie = function () {
        this.getChildren().forEach(function (node) {
            node.aboutToDie();
        });
        // beforeDestroy should run before the disposers since else we could end up in a situation where
        // a disposer added with addDisposer at this stage (beforeDestroy) is actually never released
        this.baseAboutToDie();
        this._internalEventsEmit("dispose" /* Dispose */);
        this._internalEventsClear("dispose" /* Dispose */);
    };
    ObjectNode.prototype.unregisterIdentifiers = function () {
        var _this = this;
        Object.keys(this._childNodes).forEach(function (k) {
            var childNode = _this._childNodes[k];
            if (childNode instanceof ObjectNode) {
                childNode.unregisterIdentifiers();
            }
        });
        this.root.identifierCache.notifyDied(this);
    };
    ObjectNode.prototype.finalizeDeath = function () {
        // invariant: not called directly but from "die"
        this.getChildren().forEach(function (node) {
            node.finalizeDeath();
        });
        this.root.identifierCache.notifyDied(this);
        // "kill" the computed prop and just store the last snapshot
        var snapshot = this.snapshot;
        this._snapshotUponDeath = snapshot;
        this._internalEventsClearAll();
        this.baseFinalizeDeath();
    };
    ObjectNode.prototype.onSnapshot = function (onChange) {
        this._addSnapshotReaction();
        return this._internalEventsRegister("snapshot" /* Snapshot */, onChange);
    };
    ObjectNode.prototype.emitSnapshot = function (snapshot) {
        this._internalEventsEmit("snapshot" /* Snapshot */, snapshot);
    };
    ObjectNode.prototype.onPatch = function (handler) {
        return this._internalEventsRegister("patch" /* Patch */, handler);
    };
    ObjectNode.prototype.emitPatch = function (basePatch, source) {
        if (this._internalEventsHasSubscribers("patch" /* Patch */)) {
            var localizedPatch = extend({}, basePatch, {
                path: source.path.substr(this.path.length) + "/" + basePatch.path // calculate the relative path of the patch
            });
            var _a = splitPatch(localizedPatch), patch = _a[0], reversePatch = _a[1];
            this._internalEventsEmit("patch" /* Patch */, patch, reversePatch);
        }
        if (this.parent)
            this.parent.emitPatch(basePatch, source);
    };
    ObjectNode.prototype.hasDisposer = function (disposer) {
        return this._internalEventsHas("dispose" /* Dispose */, disposer);
    };
    ObjectNode.prototype.addDisposer = function (disposer) {
        if (!this.hasDisposer(disposer)) {
            this._internalEventsRegister("dispose" /* Dispose */, disposer, true);
            return;
        }
        throw fail("cannot add a disposer when it is already registered for execution");
    };
    ObjectNode.prototype.removeDisposer = function (disposer) {
        if (!this._internalEventsHas("dispose" /* Dispose */, disposer)) {
            throw fail("cannot remove a disposer which was never registered for execution");
        }
        this._internalEventsUnregister("dispose" /* Dispose */, disposer);
    };
    ObjectNode.prototype.removeMiddleware = function (handler) {
        if (this.middlewares)
            this.middlewares = this.middlewares.filter(function (middleware) { return middleware.handler !== handler; });
    };
    ObjectNode.prototype.addMiddleWare = function (handler, includeHooks) {
        var _this = this;
        if (includeHooks === void 0) { includeHooks = true; }
        if (!this.middlewares)
            this.middlewares = [{ handler: handler, includeHooks: includeHooks }];
        else
            this.middlewares.push({ handler: handler, includeHooks: includeHooks });
        return function () {
            _this.removeMiddleware(handler);
        };
    };
    ObjectNode.prototype.applyPatchLocally = function (subpath, patch) {
        this.assertWritable({
            subpath: subpath
        });
        this.createObservableInstanceIfNeeded();
        this.type.applyPatchLocally(this, subpath, patch);
    };
    ObjectNode.prototype._addSnapshotReaction = function () {
        var _this = this;
        if (!this._hasSnapshotReaction) {
            var snapshotDisposer = reaction(function () { return _this.snapshot; }, function (snapshot) { return _this.emitSnapshot(snapshot); }, snapshotReactionOptions);
            this.addDisposer(snapshotDisposer);
            this._hasSnapshotReaction = true;
        }
    };
    // we proxy the methods to avoid creating an EventHandlers instance when it is not needed
    ObjectNode.prototype._internalEventsHasSubscribers = function (event) {
        return !!this._internalEvents && this._internalEvents.hasSubscribers(event);
    };
    ObjectNode.prototype._internalEventsRegister = function (event, eventHandler, atTheBeginning) {
        if (atTheBeginning === void 0) { atTheBeginning = false; }
        if (!this._internalEvents) {
            this._internalEvents = new EventHandlers();
        }
        return this._internalEvents.register(event, eventHandler, atTheBeginning);
    };
    ObjectNode.prototype._internalEventsHas = function (event, eventHandler) {
        return !!this._internalEvents && this._internalEvents.has(event, eventHandler);
    };
    ObjectNode.prototype._internalEventsUnregister = function (event, eventHandler) {
        if (this._internalEvents) {
            this._internalEvents.unregister(event, eventHandler);
        }
    };
    ObjectNode.prototype._internalEventsEmit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _a;
        if (this._internalEvents) {
            (_a = this._internalEvents).emit.apply(_a, [event].concat(args));
        }
    };
    ObjectNode.prototype._internalEventsClear = function (event) {
        if (this._internalEvents) {
            this._internalEvents.clear(event);
        }
    };
    ObjectNode.prototype._internalEventsClearAll = function () {
        if (this._internalEvents) {
            this._internalEvents.clearAll();
        }
    };
    tslib_1.__decorate([
        action
    ], ObjectNode.prototype, "createObservableInstanceIfNeeded", null);
    tslib_1.__decorate([
        computed
    ], ObjectNode.prototype, "snapshot", null);
    tslib_1.__decorate([
        action
    ], ObjectNode.prototype, "detach", null);
    tslib_1.__decorate([
        action
    ], ObjectNode.prototype, "die", null);
    return ObjectNode;
}(BaseNode));
export { ObjectNode };
//# sourceMappingURL=object-node.js.map