import { NodeLifeCycle, Hook, escapeJsonPath, EventHandlers, freeze, IdentifierCache, normalizeIdentifier, invalidateComputed, EMPTY_OBJECT, getLivelinessChecking, warnError, getCurrentActionContext, getPath, convertChildNodesToArray, createActionInvoker, splitJsonPath, resolveNodeByPathParts, addHiddenFinalProp, toJSON, extend, splitPatch, fail } from "../../internal";
import { createAtom, action, _allowStateChangesInsideComputed, computed, reaction } from "mobx";
// #region Object node
var nextNodeId = 1;
var snapshotReactionOptions = {
    onError: function (e) {
        throw e;
    }
};
// #endregion
function isNodeObj(node) {
    return node.kind === 1 /* Object */;
}
function isNodeScalar(node) {
    return node.kind === 0 /* Scalar */;
}
function nodeToString(node) {
    var identifier = "";
    if (isNodeObj(node)) {
        identifier = node.identifier ? "(id: " + node.identifier + ")" : "";
    }
    return node.type.name + "@" + (nodeOps.getPath(node) || "<root>") + identifier + (nodeOps.isAlive(node) ? "" : "[dead]");
}
/**
 * @internal
 * @hidden
 */
export var nodeOps = {
    isNodeObj: isNodeObj,
    isNodeScalar: isNodeScalar,
    createScalarNode: function (type, parent, subpath, environment, initialValue) {
        var node = {
            __isMstNode: true,
            kind: 0 /* Scalar */,
            type: type,
            toString: function () {
                return nodeToString(node);
            },
            parent: parent,
            subpath: subpath,
            environment: environment,
            _state: NodeLifeCycle.INITIALIZING,
            storedValue: undefined // set later
        };
        try {
            node.storedValue = type.createNewInstance(initialValue);
        }
        catch (e) {
            // short-cut to die the instance, to avoid the snapshot computed starting to throw...
            nodeOps.setState(node, NodeLifeCycle.DEAD);
            throw e;
        }
        nodeOps.setState(node, NodeLifeCycle.CREATED);
        // for scalar nodes there's no point in firing this event since it would fire on the constructor, before
        // anybody can actually register for/listen to it
        // nodeOps.fireHook(node, Hook.AfterCreate)
        nodeOps.finalizeCreation(node);
        return node;
    },
    createObjectNode: function (type, parent, subpath, environment, initialValue) {
        var initialSnapshot = freeze(initialValue);
        var node = {
            __isMstNode: true,
            kind: 1 /* Object */,
            type: type,
            toString: function () {
                return nodeToString(node);
            },
            parent: parent,
            subpath: subpath,
            environment: environment,
            _state: NodeLifeCycle.INITIALIZING,
            storedValue: undefined,
            // object node stuff
            nodeId: nextNodeId++,
            isProtectionEnabled: true,
            _autoUnbox: true,
            _isRunningAction: false,
            _hasSnapshotReaction: false,
            _observableInstanceState: 0 /* UNINITIALIZED */,
            _cachedInitialSnapshotCreated: false,
            _initialSnapshot: initialSnapshot,
            identifierAttribute: type.identifierAttribute,
            identifierCache: !parent ? new IdentifierCache() : undefined,
            identifier: null,
            unnormalizedIdentifier: null,
            // advantage of using computed for a snapshot is that nicely respects transactions etc.
            computedSnapshot: computed(function () { return freeze(nodeOps.getSnapshot(node)); }),
            unbox: function (childNode) {
                if (childNode)
                    objNodeOps.assertAlive(node, {
                        subpath: childNode.subpath || childNode.subpathUponDeath
                    });
                if (childNode && node._autoUnbox)
                    return nodeOps.valueOf(childNode);
                return childNode;
            },
            _childNodes: undefined // set later
        };
        node._childNodes = type.initializeChildNodes(node, initialSnapshot);
        // identifier can not be changed during lifecycle of a node
        // so we safely can read it from initial snapshot
        if (node.identifierAttribute && node._initialSnapshot) {
            var id = node._initialSnapshot[node.identifierAttribute];
            if (id === undefined) {
                // try with the actual node if not (for optional identifiers)
                var childNode = node._childNodes[node.identifierAttribute];
                if (childNode) {
                    id = nodeOps.valueOf(childNode);
                }
            }
            if (typeof id !== "string" && typeof id !== "number") {
                throw fail("Instance identifier '" + node.identifierAttribute + "' for type '" + node.type.name + "' must be a string or a number");
            }
            // normalize internal identifier to string
            node.identifier = normalizeIdentifier(id);
            node.unnormalizedIdentifier = id;
        }
        if (!parent) {
            node.identifierCache.addNodeToCache(node);
        }
        else {
            nodeOps.getRoot(parent).identifierCache.addNodeToCache(node);
        }
        return node;
    },
    valueOf: function (node) {
        return node.type.getValue(node);
    },
    setState: function (node, val) {
        var wasAlive = nodeOps.isAlive(node);
        node._state = val;
        var isAlive = nodeOps.isAlive(node);
        if (node._aliveAtom && wasAlive !== isAlive) {
            node._aliveAtom.reportChanged();
        }
    },
    isAlive: function (node) {
        return node._state !== NodeLifeCycle.DEAD;
    },
    observableIsAlive: function (node) {
        if (!node._aliveAtom) {
            node._aliveAtom = createAtom("alive");
        }
        node._aliveAtom.reportObserved();
        return nodeOps.isAlive(node);
    },
    isDetaching: function (node) {
        return node._state === NodeLifeCycle.DETACHING;
    },
    registerHook: function (node, hook, hookHandler) {
        if (!node._hookSubscribers) {
            node._hookSubscribers = new EventHandlers();
        }
        return node._hookSubscribers.register(hook, hookHandler);
    },
    baseSetParent: function (node, parent, subpath) {
        node.parent = parent;
        node.subpath = subpath;
        node._escapedSubpath = undefined; // regenerate when needed
        if (node._pathAtom) {
            node._pathAtom.reportChanged();
        }
    },
    getPath: function (node) {
        return nodeOps.getEscapedPath(node, true);
    },
    getEscapedPath: function (node, reportObserved) {
        if (reportObserved) {
            if (!node._pathAtom) {
                node._pathAtom = createAtom("path");
            }
            node._pathAtom.reportObserved();
        }
        if (!node.parent)
            return "";
        // regenerate escaped subpath if needed
        if (node._escapedSubpath === undefined) {
            node._escapedSubpath = !node.subpath ? "" : escapeJsonPath(node.subpath);
        }
        return nodeOps.getEscapedPath(node.parent, reportObserved) + "/" + node._escapedSubpath;
    },
    isRoot: function (node) {
        return node.parent === null;
    },
    finalizeDeath: function (node) {
        if (isNodeObj(node)) {
            // invariant: not called directly but from "die"
            objNodeOps.getChildren(node).forEach(function (n) {
                nodeOps.finalizeDeath(n);
            });
            nodeOps.getRoot(node).identifierCache.notifyDied(node);
            // "kill" the computed prop and just store the last snapshot
            var snapshot = nodeOps.snapshotOf(node);
            node._snapshotUponDeath = snapshot;
            objNodeOps._internalEventsClearAll(node);
        }
        if (node._hookSubscribers) {
            node._hookSubscribers.clearAll();
        }
        node.subpathUponDeath = node.subpath;
        node.pathUponDeath = nodeOps.getEscapedPath(node, false);
        nodeOps.baseSetParent(node, null, "");
        nodeOps.setState(node, NodeLifeCycle.DEAD);
    },
    fireHook: function (node, name) {
        if (node._hookSubscribers) {
            node._hookSubscribers.emit(name, node, name);
        }
        if (isNodeObj(node)) {
            var fn_1 = node.storedValue &&
                typeof node.storedValue === "object" &&
                node.storedValue[name];
            if (typeof fn_1 === "function") {
                // we check for it to allow old mobx peer dependencies that don't have the method to work (even when still bugged)
                if (_allowStateChangesInsideComputed) {
                    _allowStateChangesInsideComputed(function () {
                        fn_1.apply(node.storedValue);
                    });
                }
                else {
                    fn_1.apply(node.storedValue);
                }
            }
        }
    },
    getRoot: function (node) {
        if (isNodeObj(node)) {
            return node.parent ? nodeOps.getRoot(node.parent) : node;
        }
        else {
            // future optimization: store root ref in the node and maintain it
            if (!node.parent)
                throw fail("This scalar node is not part of a tree");
            return nodeOps.getRoot(node.parent);
        }
    },
    setParent: function (node, newParent, subpath) {
        if (node.parent === newParent && node.subpath === subpath)
            return;
        if (node.kind === 1 /* Object */) {
            if (newParent && process.env.NODE_ENV !== "production") {
                if (node.parent && newParent !== node.parent) {
                    throw fail("A node cannot exists twice in the state tree. Failed to add " + node + " to path '" + nodeOps.getPath(newParent) + "/" + subpath + "'.");
                }
                var newParentRoot = nodeOps.getRoot(newParent);
                if (!node.parent && newParentRoot === node) {
                    throw fail("A state tree is not allowed to contain itself. Cannot assign " + node + " to path '" + nodeOps.getPath(newParent) + "/" + subpath + "'");
                }
                var root = nodeOps.getRoot(node);
                if (!node.parent &&
                    !!root.environment &&
                    root.environment !== newParentRoot.environment) {
                    throw fail("A state tree cannot be made part of another state tree as long as their environments are different.");
                }
            }
        }
        if (node.parent && !newParent) {
            nodeOps.die(node);
        }
        else {
            var newPath = subpath === null ? "" : subpath;
            if (newParent && newParent !== node.parent) {
                if (isNodeObj(node)) {
                    nodeOps.getRoot(newParent).identifierCache.mergeCache(node);
                    nodeOps.baseSetParent(node, newParent, newPath);
                    nodeOps.fireHook(node, Hook.afterAttach);
                }
                else {
                    throw fail("assertion failed: scalar nodes cannot change their parent");
                }
            }
            else if (node.subpath !== newPath) {
                nodeOps.baseSetParent(node, node.parent, newPath);
            }
        }
    },
    snapshotOf: function (node) {
        if (isNodeObj(node)) {
            return node.computedSnapshot.get();
        }
        else {
            return freeze(nodeOps.getSnapshot(node));
        }
    },
    // NOTE: we use this method to get snapshot without creating @computed overhead
    getSnapshot: function (node) {
        var sn;
        if (isNodeObj(node)) {
            if (!nodeOps.isAlive(node))
                return node._snapshotUponDeath;
            if (node._observableInstanceState === 2 /* CREATED */) {
                sn = node.type.getSnapshot(node);
            }
            else {
                if (!node._cachedInitialSnapshotCreated) {
                    var type = node.type;
                    var childNodes = node._childNodes;
                    var snapshot = node._initialSnapshot;
                    node._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);
                    node._cachedInitialSnapshotCreated = true;
                }
                sn = node._cachedInitialSnapshot;
            }
        }
        else {
            sn = node.type.getSnapshot(node);
        }
        if (node.snapshotPostProcessors) {
            node.snapshotPostProcessors.forEach(function (snapshotPostProcessor) {
                sn = snapshotPostProcessor(sn);
            });
        }
        return sn;
    },
    die: action(function (node) {
        if (nodeOps.isDetaching(node))
            return;
        if (isNodeObj(node) &&
            node._observableInstanceState !== 2 /* CREATED */) {
            // get rid of own and child ids at least
            objNodeOps.unregisterIdentifiers(node);
        }
        else {
            nodeOps.aboutToDie(node);
            nodeOps.finalizeDeath(node);
        }
    }),
    finalizeCreation: function (node) {
        // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already
        if (node._state === NodeLifeCycle.CREATED) {
            if (node.parent) {
                if (node.parent._state !== NodeLifeCycle.FINALIZED) {
                    // parent not ready yet, postpone
                    return;
                }
                nodeOps.fireHook(node, Hook.afterAttach);
            }
            nodeOps.setState(node, NodeLifeCycle.FINALIZED);
            if (isNodeObj(node)) {
                for (var _i = 0, _a = objNodeOps.getChildren(node); _i < _a.length; _i++) {
                    var child = _a[_i];
                    nodeOps.finalizeCreation(child);
                }
                // could be called for scalar, but it would be called on the constructor
                nodeOps.fireHook(node, Hook.afterCreationFinalization);
            }
        }
    },
    aboutToDie: function (node) {
        if (isNodeObj(node)) {
            objNodeOps.getChildren(node).forEach(function (n) {
                nodeOps.aboutToDie(n);
            });
        }
        // beforeDestroy should run before the disposers since else we could end up in a situation where
        // a disposer added with addDisposer at this stage (beforeDestroy) is actually never released
        nodeOps.fireHook(node, Hook.beforeDestroy);
        if (isNodeObj(node)) {
            objNodeOps._internalEventsEmit(node, "dispose" /* Dispose */);
            objNodeOps._internalEventsClear(node, "dispose" /* Dispose */);
        }
    }
};
/**
 * @internal
 * @hidden
 */
export var objNodeOps = {
    applyPatches: function (node, patches) {
        objNodeOps.createObservableInstanceIfNeeded(node);
        node._applyPatches(patches);
    },
    applySnapshot: function (node, snapshot) {
        objNodeOps.createObservableInstanceIfNeeded(node);
        node._applySnapshot(snapshot);
    },
    createObservableInstanceIfNeeded: action(function (node) {
        if (node._observableInstanceState !== 0 /* UNINITIALIZED */) {
            return;
        }
        node._observableInstanceState = 1 /* CREATING */;
        // make sure the parent chain is created as well
        // array with parent chain from parent to child
        var parentChain = [];
        var parent = node.parent;
        // for performance reasons we never go back further than the most direct
        // uninitialized parent
        // this is done to avoid traversing the whole tree to the root when using
        // the same reference again
        while (parent &&
            parent._observableInstanceState === 0 /* UNINITIALIZED */) {
            parentChain.unshift(parent);
            parent = parent.parent;
        }
        // initialize the uninitialized parent chain from parent to child
        for (var _i = 0, parentChain_1 = parentChain; _i < parentChain_1.length; _i++) {
            var p = parentChain_1[_i];
            objNodeOps.createObservableInstanceIfNeeded(p);
        }
        var type = node.type;
        try {
            node.storedValue = type.createNewInstance(node, node._childNodes, node._initialSnapshot);
            objNodeOps.preboot(node);
            node._isRunningAction = true;
            type.finalizeNewInstance(node, node.storedValue);
        }
        catch (e) {
            // short-cut to die the instance, to avoid the snapshot computed starting to throw...
            nodeOps.setState(node, NodeLifeCycle.DEAD);
            throw e;
        }
        finally {
            node._isRunningAction = false;
        }
        node._observableInstanceState = 2 /* CREATED */;
        // NOTE: we need to touch snapshot, because non-observable
        // "_observableInstanceState" field was touched
        invalidateComputed(node.computedSnapshot);
        if (nodeOps.isRoot(node))
            objNodeOps._addSnapshotReaction(node);
        node._childNodes = EMPTY_OBJECT;
        nodeOps.setState(node, NodeLifeCycle.CREATED);
        nodeOps.fireHook(node, Hook.afterCreate);
        nodeOps.finalizeCreation(node);
    }),
    isRunningAction: function (node) {
        if (node._isRunningAction)
            return true;
        if (nodeOps.isRoot(node))
            return false;
        return objNodeOps.isRunningAction(node.parent);
    },
    assertAlive: function (node, context) {
        var livelinessChecking = getLivelinessChecking();
        if (!nodeOps.isAlive(node) && livelinessChecking !== "ignore") {
            var error = objNodeOps._getAssertAliveError(node, context);
            switch (livelinessChecking) {
                case "error":
                    throw fail(error);
                case "warn":
                    warnError(error);
            }
        }
    },
    _getAssertAliveError: function (node, context) {
        var escapedPath = nodeOps.getEscapedPath(node, false) || node.pathUponDeath || "";
        var subpath = (context.subpath && escapeJsonPath(context.subpath)) || "";
        var actionContext = context.actionContext || getCurrentActionContext();
        var actionFullPath = "";
        if (actionContext && actionContext.name != null) {
            // try to use the context, and if it not available use the node one
            var actionPath = (actionContext && actionContext.context && getPath(actionContext.context)) ||
                escapedPath;
            actionFullPath = actionPath + "." + actionContext.name + "()";
        }
        return "You are trying to read or write to an object that is no longer part of a state tree. (Object type: '" + node.type.name + "', Path upon death: '" + escapedPath + "', Subpath: '" + subpath + "', Action: '" + actionFullPath + "'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.";
    },
    getChildNode: function (node, subpath) {
        objNodeOps.assertAlive(node, {
            subpath: subpath
        });
        node._autoUnbox = false;
        try {
            return node._observableInstanceState === 2 /* CREATED */
                ? node.type.getChildNode(node, subpath)
                : node._childNodes[subpath];
        }
        finally {
            node._autoUnbox = true;
        }
    },
    getChildren: function (node) {
        objNodeOps.assertAlive(node, EMPTY_OBJECT);
        node._autoUnbox = false;
        try {
            return node._observableInstanceState === 2 /* CREATED */
                ? node.type.getChildren(node)
                : convertChildNodesToArray(node._childNodes);
        }
        finally {
            node._autoUnbox = true;
        }
    },
    getChildType: function (node, propertyName) {
        return node.type.getChildType(propertyName);
    },
    isProtected: function (node) {
        return nodeOps.getRoot(node).isProtectionEnabled;
    },
    assertWritable: function (node, context) {
        objNodeOps.assertAlive(node, context);
        if (!objNodeOps.isRunningAction(node) && objNodeOps.isProtected(node)) {
            throw fail("Cannot modify '" + node + "', the object is protected and can only be modified by using an action.");
        }
    },
    removeChild: function (node, subpath) {
        node.type.removeChild(node, subpath);
    },
    detach: action(function (node) {
        if (!nodeOps.isAlive(node))
            throw fail("Error while detaching, node is not alive.");
        if (nodeOps.isRoot(node))
            return;
        nodeOps.fireHook(node, Hook.beforeDetach);
        nodeOps.setState(node, NodeLifeCycle.DETACHING);
        var root = nodeOps.getRoot(node);
        var newEnv = root.environment;
        var newIdCache = root.identifierCache.splitCache(node);
        try {
            objNodeOps.removeChild(node.parent, node.subpath);
            nodeOps.baseSetParent(node, null, "");
            node.environment = newEnv;
            node.identifierCache = newIdCache;
        }
        finally {
            nodeOps.setState(node, NodeLifeCycle.FINALIZED);
        }
    }),
    preboot: function (node) {
        node._applyPatches = createActionInvoker(node.storedValue, "@APPLY_PATCHES", function (patches) {
            patches.forEach(function (patch) {
                var parts = splitJsonPath(patch.path);
                var node2 = resolveNodeByPathParts(node, parts.slice(0, -1));
                objNodeOps.applyPatchLocally(node2, parts[parts.length - 1], patch);
            });
        });
        node._applySnapshot = createActionInvoker(node.storedValue, "@APPLY_SNAPSHOT", function (snapshot) {
            // if the snapshot is the same as the current one, avoid performing a reconcile
            if (snapshot === nodeOps.snapshotOf(node))
                return;
            // else, apply it by calling the type logic
            return node.type.applySnapshot(node, snapshot);
        });
        addHiddenFinalProp(node.storedValue, "$treenode", node);
        addHiddenFinalProp(node.storedValue, "toJSON", toJSON);
    },
    unregisterIdentifiers: function (node) {
        Object.keys(node._childNodes).forEach(function (k) {
            var childNode = node._childNodes[k];
            if (isNodeObj(childNode)) {
                objNodeOps.unregisterIdentifiers(childNode);
            }
        });
        nodeOps.getRoot(node).identifierCache.notifyDied(node);
    },
    onSnapshot: function (node, onChange) {
        objNodeOps._addSnapshotReaction(node);
        return objNodeOps._internalEventsRegister(node, "snapshot" /* Snapshot */, onChange);
    },
    emitSnapshot: function (node, snapshot) {
        objNodeOps._internalEventsEmit(node, "snapshot" /* Snapshot */, snapshot);
    },
    onPatch: function (node, handler) {
        return objNodeOps._internalEventsRegister(node, "patch" /* Patch */, handler);
    },
    emitPatch: function (node, basePatch, source) {
        if (objNodeOps._internalEventsHasSubscribers(node, "patch" /* Patch */)) {
            var localizedPatch = extend({}, basePatch, {
                path: nodeOps.getPath(source).substr(nodeOps.getPath(node).length) +
                    "/" +
                    basePatch.path // calculate the relative path of the patch
            });
            var _a = splitPatch(localizedPatch), patch = _a[0], reversePatch = _a[1];
            objNodeOps._internalEventsEmit(node, "patch" /* Patch */, patch, reversePatch);
        }
        if (node.parent)
            objNodeOps.emitPatch(node.parent, basePatch, source);
    },
    hasDisposer: function (node, disposer) {
        return objNodeOps._internalEventsHas(node, "dispose" /* Dispose */, disposer);
    },
    addDisposer: function (node, disposer) {
        if (!objNodeOps.hasDisposer(node, disposer)) {
            objNodeOps._internalEventsRegister(node, "dispose" /* Dispose */, disposer, true);
            return;
        }
        throw fail("cannot add a disposer when it is already registered for execution");
    },
    removeDisposer: function (node, disposer) {
        if (!objNodeOps._internalEventsHas(node, "dispose" /* Dispose */, disposer)) {
            throw fail("cannot remove a disposer which was never registered for execution");
        }
        objNodeOps._internalEventsUnregister(node, "dispose" /* Dispose */, disposer);
    },
    removeMiddleware: function (node, handler) {
        if (node.middlewares)
            node.middlewares = node.middlewares.filter(function (middleware) { return middleware.handler !== handler; });
    },
    addMiddleWare: function (node, handler, includeHooks) {
        if (includeHooks === void 0) { includeHooks = true; }
        if (!node.middlewares)
            node.middlewares = [{ handler: handler, includeHooks: includeHooks }];
        else
            node.middlewares.push({ handler: handler, includeHooks: includeHooks });
        return function () {
            objNodeOps.removeMiddleware(node, handler);
        };
    },
    applyPatchLocally: function (node, subpath, patch) {
        objNodeOps.assertWritable(node, {
            subpath: subpath
        });
        objNodeOps.createObservableInstanceIfNeeded(node);
        node.type.applyPatchLocally(node, subpath, patch);
    },
    _addSnapshotReaction: function (node) {
        if (!node._hasSnapshotReaction) {
            var snapshotDisposer = reaction(function () { return nodeOps.snapshotOf(node); }, function (snapshot) { return objNodeOps.emitSnapshot(node, snapshot); }, snapshotReactionOptions);
            objNodeOps.addDisposer(node, snapshotDisposer);
            node._hasSnapshotReaction = true;
        }
    },
    // #region internal event handling
    // we proxy the methods to avoid creating an EventHandlers instance when it is not needed
    _internalEventsHasSubscribers: function (node, event) {
        return !!node._internalEvents && node._internalEvents.hasSubscribers(event);
    },
    _internalEventsRegister: function (node, event, eventHandler, atTheBeginning) {
        if (atTheBeginning === void 0) { atTheBeginning = false; }
        if (!node._internalEvents) {
            node._internalEvents = new EventHandlers();
        }
        return node._internalEvents.register(event, eventHandler, atTheBeginning);
    },
    _internalEventsHas: function (node, event, eventHandler) {
        return !!node._internalEvents && node._internalEvents.has(event, eventHandler);
    },
    _internalEventsUnregister: function (node, event, eventHandler) {
        if (node._internalEvents) {
            node._internalEvents.unregister(event, eventHandler);
        }
    },
    _internalEventsEmit: function (node, event) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var _a;
        if (node._internalEvents) {
            (_a = node._internalEvents).emit.apply(_a, [event].concat(args));
        }
    },
    _internalEventsClear: function (node, event) {
        if (node._internalEvents) {
            node._internalEvents.clear(event);
        }
    },
    _internalEventsClearAll: function (node) {
        if (node._internalEvents) {
            node._internalEvents.clearAll();
        }
    }
    // #endregion
};
//# sourceMappingURL=node.js.map