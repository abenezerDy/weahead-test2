import { values, observable, entries } from "mobx";
import { fail, mobxShallow } from "../../internal";
var identifierCacheId = 0;
/**
 * @internal
 * @hidden
 */
var IdentifierCache = /** @class */ (function () {
    function IdentifierCache() {
        this.cacheId = identifierCacheId++;
        // n.b. in cache all identifiers are normalized to strings
        this.cache = observable.map();
        // last time the cache (array) for a given time changed
        // n.b. it is not really the time, but just an integer that gets increased after each modification to the array
        this.lastCacheModificationPerId = observable.map();
    }
    IdentifierCache.prototype.updateLastCacheModificationPerId = function (identifier) {
        var lcm = this.lastCacheModificationPerId.get(identifier);
        // we start at 1 since 0 means no update since cache creation
        this.lastCacheModificationPerId.set(identifier, lcm === undefined ? 1 : lcm + 1);
    };
    IdentifierCache.prototype.getLastCacheModificationPerId = function (identifier) {
        var modificationId = this.lastCacheModificationPerId.get(identifier) || 0;
        return this.cacheId + "-" + modificationId;
    };
    IdentifierCache.prototype.addNodeToCache = function (node, lastCacheUpdate) {
        if (lastCacheUpdate === void 0) { lastCacheUpdate = true; }
        if (node.identifierAttribute) {
            var identifier = node.identifier;
            if (!this.cache.has(identifier)) {
                this.cache.set(identifier, observable.array([], mobxShallow));
            }
            var set = this.cache.get(identifier);
            if (set.indexOf(node) !== -1)
                throw fail("Already registered");
            set.push(node);
            if (lastCacheUpdate) {
                this.updateLastCacheModificationPerId(identifier);
            }
        }
    };
    IdentifierCache.prototype.mergeCache = function (node) {
        var _this = this;
        values(node.identifierCache.cache).forEach(function (nodes) {
            return nodes.forEach(function (child) {
                _this.addNodeToCache(child);
            });
        });
    };
    IdentifierCache.prototype.notifyDied = function (node) {
        if (node.identifierAttribute) {
            var id = node.identifier;
            var set = this.cache.get(id);
            if (set) {
                set.remove(node);
                // remove empty sets from cache
                if (!set.length) {
                    this.cache.delete(id);
                }
                this.updateLastCacheModificationPerId(node.identifier);
            }
        }
    };
    IdentifierCache.prototype.splitCache = function (node) {
        var _this = this;
        var res = new IdentifierCache();
        var basePath = node.path;
        entries(this.cache).forEach(function (_a) {
            var id = _a[0], nodes = _a[1];
            var modified = false;
            for (var i = nodes.length - 1; i >= 0; i--) {
                if (nodes[i].path.indexOf(basePath) === 0) {
                    res.addNodeToCache(nodes[i], false); // no need to update lastUpdated since it is a whole new cache
                    nodes.splice(i, 1);
                    modified = true;
                }
            }
            if (modified) {
                _this.updateLastCacheModificationPerId(id);
            }
        });
        return res;
    };
    IdentifierCache.prototype.has = function (type, identifier) {
        var set = this.cache.get(identifier);
        if (!set)
            return false;
        return set.some(function (candidate) { return type.isAssignableFrom(candidate.type); });
    };
    IdentifierCache.prototype.resolve = function (type, identifier) {
        var set = this.cache.get(identifier);
        if (!set)
            return null;
        var matches = set.filter(function (candidate) { return type.isAssignableFrom(candidate.type); });
        switch (matches.length) {
            case 0:
                return null;
            case 1:
                return matches[0];
            default:
                throw fail("Cannot resolve a reference to type '" + type.name + "' with id: '" + identifier + "' unambigously, there are multiple candidates: " + matches
                    .map(function (n) { return n.path; })
                    .join(", "));
        }
    };
    return IdentifierCache;
}());
export { IdentifierCache };
//# sourceMappingURL=identifier-cache.js.map