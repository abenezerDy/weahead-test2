import { action as mobxAction } from "mobx";
import { getStateTreeNode, fail, argsToArray, getRoot, EMPTY_ARRAY, Hook, warnError } from "../internal";
var nextActionId = 1;
var currentActionContext = null;
/**
 * @internal
 * @hidden
 */
export function getCurrentActionContext() {
    return currentActionContext;
}
/**
 * @internal
 * @hidden
 */
export function getNextActionId() {
    return nextActionId++;
}
// TODO: optimize away entire action context if there is no middleware in tree?
/**
 * @internal
 * @hidden
 */
export function runWithActionContext(context, fn) {
    var node = getStateTreeNode(context.context);
    var baseIsRunningAction = node._isRunningAction;
    var prevContext = currentActionContext;
    if (context.type === "action") {
        node.assertAlive({
            actionContext: context
        });
    }
    node._isRunningAction = true;
    currentActionContext = context;
    try {
        return runMiddleWares(node, context, fn);
    }
    finally {
        currentActionContext = prevContext;
        node._isRunningAction = baseIsRunningAction;
    }
}
/**
 * @internal
 * @hidden
 */
export function getActionContext() {
    if (!currentActionContext)
        throw fail("Not running an action!");
    return currentActionContext;
}
/**
 * @internal
 * @hidden
 */
export function createActionInvoker(target, name, fn) {
    var res = function () {
        var id = getNextActionId();
        return runWithActionContext({
            type: "action",
            name: name,
            id: id,
            args: argsToArray(arguments),
            context: target,
            tree: getRoot(target),
            rootId: currentActionContext ? currentActionContext.rootId : id,
            parentId: currentActionContext ? currentActionContext.id : 0,
            allParentIds: currentActionContext
                ? currentActionContext.allParentIds.concat([currentActionContext.id]) : []
        }, fn);
    };
    res._isMSTAction = true;
    return res;
}
/**
 * Middleware can be used to intercept any action is invoked on the subtree where it is attached.
 * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.
 *
 * For more details, see the [middleware docs](../middleware.md)
 *
 * @param target Node to apply the middleware to.
 * @param middleware Middleware to apply.
 * @returns A callable function to dispose the middleware.
 */
export function addMiddleware(target, handler, includeHooks) {
    if (includeHooks === void 0) { includeHooks = true; }
    var node = getStateTreeNode(target);
    if (process.env.NODE_ENV !== "production") {
        if (!node.isProtectionEnabled) {
            warnError("It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`");
        }
    }
    return node.addMiddleWare(handler, includeHooks);
}
/**
 * Binds middleware to a specific action.
 *
 * Example:
 * ```ts
 * type.actions(self => {
 *   function takeA____() {
 *       self.toilet.donate()
 *       self.wipe()
 *       self.wipe()
 *       self.toilet.flush()
 *   }
 *   return {
 *     takeA____: decorate(atomic, takeA____)
 *   }
 * })
 * ```
 *
 * @param handler
 * @param fn
 * @returns The original function
 */
export function decorate(handler, fn) {
    var middleware = { handler: handler, includeHooks: true };
    if (fn.$mst_middleware)
        fn.$mst_middleware.push(middleware);
    else
        ;
    ;
    fn.$mst_middleware = [middleware];
    return fn;
}
function collectMiddlewares(node, baseCall, fn) {
    var middlewares = fn.$mst_middleware || EMPTY_ARRAY;
    var n = node;
    // Find all middlewares. Optimization: cache this?
    while (n) {
        if (n.middlewares)
            middlewares = middlewares.concat(n.middlewares);
        n = n.parent;
    }
    return middlewares;
}
function runMiddleWares(node, baseCall, originalFn) {
    var middlewares = collectMiddlewares(node, baseCall, originalFn);
    // Short circuit
    if (!middlewares.length)
        return mobxAction(originalFn).apply(null, baseCall.args);
    var index = 0;
    var result = null;
    function runNextMiddleware(call) {
        var middleware = middlewares[index++];
        var handler = middleware && middleware.handler;
        if (!handler) {
            return mobxAction(originalFn).apply(null, call.args);
        }
        // skip hooks if asked to
        if (!middleware.includeHooks && Hook[call.name]) {
            return runNextMiddleware(call);
        }
        var nextInvoked = false;
        function next(call2, callback) {
            nextInvoked = true;
            // the result can contain
            // - the non manipulated return value from an action
            // - the non manipulated abort value
            // - one of the above but manipulated through the callback function
            var innerResult = runNextMiddleware(call2);
            if (callback) {
                result = callback(innerResult);
            }
            else {
                result = innerResult;
            }
        }
        var abortInvoked = false;
        function abort(value) {
            abortInvoked = true;
            // overwrite the result
            // can be manipulated through middlewares earlier in the queue using the callback fn
            result = value;
        }
        handler(call, next, abort);
        if (process.env.NODE_ENV !== "production") {
            if (!nextInvoked && !abortInvoked) {
                var node2 = getStateTreeNode(call.tree);
                throw fail("Neither the next() nor the abort() callback within the middleware " + handler.name + " for the action: \"" + call.name + "\" on the node: " + node2.type.name + " was invoked.");
            }
            else if (nextInvoked && abortInvoked) {
                var node2 = getStateTreeNode(call.tree);
                throw fail("The next() and abort() callback within the middleware " + handler.name + " for the action: \"" + call.name + "\" on the node: " + node2.type.name + " were invoked.");
            }
        }
        return result;
    }
    return runNextMiddleware(baseCall);
}
//# sourceMappingURL=action.js.map