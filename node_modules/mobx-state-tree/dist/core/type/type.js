import * as tslib_1 from "tslib";
import { action } from "mobx";
import { fail, isMutable, isStateTreeNode, getStateTreeNode, typecheckInternal, typeCheckFailure, typeCheckSuccess, getType, normalizeIdentifier, getStateTreeNodeSafe } from "../../internal";
/**
 * @internal
 * @hidden
 */
export var TypeFlags;
(function (TypeFlags) {
    TypeFlags[TypeFlags["String"] = 1] = "String";
    TypeFlags[TypeFlags["Number"] = 2] = "Number";
    TypeFlags[TypeFlags["Boolean"] = 4] = "Boolean";
    TypeFlags[TypeFlags["Date"] = 8] = "Date";
    TypeFlags[TypeFlags["Literal"] = 16] = "Literal";
    TypeFlags[TypeFlags["Array"] = 32] = "Array";
    TypeFlags[TypeFlags["Map"] = 64] = "Map";
    TypeFlags[TypeFlags["Object"] = 128] = "Object";
    TypeFlags[TypeFlags["Frozen"] = 256] = "Frozen";
    TypeFlags[TypeFlags["Optional"] = 512] = "Optional";
    TypeFlags[TypeFlags["Reference"] = 1024] = "Reference";
    TypeFlags[TypeFlags["Identifier"] = 2048] = "Identifier";
    TypeFlags[TypeFlags["Late"] = 4096] = "Late";
    TypeFlags[TypeFlags["Refinement"] = 8192] = "Refinement";
    TypeFlags[TypeFlags["Union"] = 16384] = "Union";
    TypeFlags[TypeFlags["Null"] = 32768] = "Null";
    TypeFlags[TypeFlags["Undefined"] = 65536] = "Undefined";
    TypeFlags[TypeFlags["Integer"] = 131072] = "Integer";
    TypeFlags[TypeFlags["Custom"] = 262144] = "Custom";
    TypeFlags[TypeFlags["SnapshotProcessor"] = 524288] = "SnapshotProcessor";
})(TypeFlags || (TypeFlags = {}));
/**
 * @internal
 * @hidden
 */
export var cannotDetermineSubtype = "cannotDetermine";
/**
 * A base type produces a MST node (Node in the state tree)
 *
 * @internal
 * @hidden
 */
var BaseType = /** @class */ (function () {
    function BaseType(name) {
        this.isType = true;
        this.name = name;
    }
    BaseType.prototype.create = function (snapshot, environment) {
        typecheckInternal(this, snapshot);
        return this.instantiate(null, "", environment, snapshot).value;
    };
    BaseType.prototype.getSnapshot = function (node, applyPostProcess) {
        if (applyPostProcess === void 0) { applyPostProcess = true; }
        return node.type.getSnapshot(node, applyPostProcess);
    };
    BaseType.prototype.isAssignableFrom = function (type) {
        return type === this;
    };
    BaseType.prototype.validate = function (value, context) {
        var node = getStateTreeNodeSafe(value);
        if (node) {
            var valueType = getType(value);
            return this.isAssignableFrom(valueType)
                ? typeCheckSuccess()
                : typeCheckFailure(context, value);
            // it is tempting to compare snapshots, but in that case we should always clone on assignments...
        }
        return this.isValidSnapshot(value, context);
    };
    BaseType.prototype.is = function (thing) {
        return this.validate(thing, [{ path: "", type: this }]).length === 0;
    };
    Object.defineProperty(BaseType.prototype, "Type", {
        get: function () {
            throw fail("Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseType.prototype, "SnapshotType", {
        get: function () {
            throw fail("Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseType.prototype, "CreationType", {
        get: function () {
            throw fail("Factory.CreationType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.CreationType`");
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        action
    ], BaseType.prototype, "create", null);
    return BaseType;
}());
export { BaseType };
/**
 * A complex type produces a MST node (Node in the state tree)
 *
 * @internal
 * @hidden
 */
var ComplexType = /** @class */ (function (_super) {
    tslib_1.__extends(ComplexType, _super);
    function ComplexType(name) {
        return _super.call(this, name) || this;
    }
    ComplexType.prototype.create = function (snapshot, environment) {
        if (snapshot === void 0) { snapshot = this.getDefaultSnapshot(); }
        return _super.prototype.create.call(this, snapshot, environment);
    };
    ComplexType.prototype.getValue = function (node) {
        node.createObservableInstanceIfNeeded();
        return node.storedValue;
    };
    ComplexType.prototype.reconcile = function (current, newValue) {
        // if the node we are trying to reconcile is being detached we have to use a new one and
        // let the current one alive
        if (!current.isDetaching) {
            if (current.snapshot === newValue)
                // newValue is the current snapshot of the node, noop
                return current;
            if (isStateTreeNode(newValue) && getStateTreeNode(newValue) === current)
                // the current node is the same as the new one
                return current;
            if (current.type === this &&
                isMutable(newValue) &&
                !isStateTreeNode(newValue) &&
                (!current.identifierAttribute ||
                    current.identifier ===
                        normalizeIdentifier(newValue[current.identifierAttribute]))) {
                // the newValue has no node, so can be treated like a snapshot
                // we can reconcile
                current.applySnapshot(newValue);
                return current;
            }
        }
        // current node cannot be recycled in any way
        var parent = current.parent, subpath = current.subpath;
        current.die(); // noop if detaching
        // attempt to reuse the new one
        if (isStateTreeNode(newValue) && this.isAssignableFrom(getType(newValue))) {
            // newValue is a Node as well, move it here..
            var newNode = getStateTreeNode(newValue);
            newNode.setParent(parent, subpath);
            return newNode;
        }
        // nothing to do, we have to create a new node
        return this.instantiate(parent, subpath, current.environment, newValue);
    };
    ComplexType.prototype.getSubTypes = function () {
        return null;
    };
    tslib_1.__decorate([
        action
    ], ComplexType.prototype, "create", null);
    return ComplexType;
}(BaseType));
export { ComplexType };
/**
 * @internal
 * @hidden
 */
var SimpleType = /** @class */ (function (_super) {
    tslib_1.__extends(SimpleType, _super);
    function SimpleType() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleType.prototype.createNewInstance = function (snapshot) {
        return snapshot;
    };
    SimpleType.prototype.getValue = function (node) {
        // if we ever find a case where scalar nodes can be accessed without iterating through its parent
        // uncomment this to make sure the parent chain is created when this is accessed
        // if (node.parent) {
        //     node.parent.createObservableInstanceIfNeeded()
        // }
        return node.storedValue;
    };
    SimpleType.prototype.getSnapshot = function (node) {
        return node.storedValue;
    };
    SimpleType.prototype.reconcile = function (current, newValue) {
        // reconcile only if type and value are still the same, and only if the node is not detaching
        if (!current.isDetaching && current.type === this && current.storedValue === newValue) {
            return current;
        }
        var res = this.instantiate(current.parent, current.subpath, current.environment, newValue);
        current.die(); // noop if detaching
        return res;
    };
    SimpleType.prototype.getSubTypes = function () {
        return null;
    };
    return SimpleType;
}(BaseType));
export { SimpleType };
/**
 * Returns if a given value represents a type.
 *
 * @param value Value to check.
 * @returns `true` if the value is a type.
 */
export function isType(value) {
    return typeof value === "object" && value && value.isType === true;
}
//# sourceMappingURL=type.js.map